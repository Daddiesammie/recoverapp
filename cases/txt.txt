# cases/api.py
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from django.utils import timezone
from datetime import timedelta
from .models import Case, VerificationCode

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def verify_code(request, case_id):
    try:
        case = Case.objects.get(id=case_id, user=request.user)
        if case.status != 'approved':
            return Response({'error': 'Case is not approved for verification'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        current_step = case.verificationcode_set.filter(is_used=True).count() + 1
        if current_step > 3:
            return Response({'error': 'Verification process already completed'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        code = request.data.get('code')
        verification = VerificationCode.objects.filter(
            case=case,
            step=current_step,
            code=code,
            is_used=False,
            expires_at__gt=timezone.now()
        ).first()

        if not verification:
            return Response({'error': 'Invalid or expired code'}, 
                          status=status.HTTP_400_BAD_REQUEST)

        verification.is_used = True
        verification.save()

        if current_step == 3:
            case.status = 'completed'
            case.save()

        return Response({'success': True, 'step': current_step})

    except Case.DoesNotExist:
        return Response({'error': 'Case not found'}, 
                      status=status.HTTP_404_NOT_FOUND)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def request_new_code(request, case_id):
    try:
        case = Case.objects.get(id=case_id, user=request.user)
        current_step = case.verificationcode_set.filter(is_used=True).count() + 1
        
        if current_step > 3:
            return Response({'error': 'Verification process already completed'}, 
                            status=status.HTTP_400_BAD_REQUEST)

        # Check if a verification code already exists for the current step
        existing_code = VerificationCode.objects.filter(case=case, step=current_step, is_used=False).first()
        if existing_code:
            return Response({'error': 'A verification code for this step already exists'}, 
                            status=status.HTTP_400_BAD_REQUEST)

        # Generate new verification code
        code = VerificationCode.generate_code()
        expires_at = timezone.now() + timedelta(minutes=30)
        
        VerificationCode.objects.create(
            case=case,
            code=code,
            step=current_step,
            expires_at=expires_at
        )

        # Send code via email
        send_verification_code_email(case, code, current_step)

        return Response({'success': True, 'message': 'New code sent'})

    except Case.DoesNotExist:
        return Response({'error': 'Case not found'}, 
                        status=status.HTTP_404_NOT_FOUND)



# cases/views.py
from django.db.models import Sum
from django.utils import timezone
from django.http import JsonResponse
from django.views.generic import CreateView, ListView, DetailView
from django.contrib.auth.mixins import LoginRequiredMixin
from .models import Case, VerificationCode
from .forms import CaseForm
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.conf import settings
from django.urls import reverse

class CaseCreateView(LoginRequiredMixin, CreateView):
    # ... existing code ...

    def form_valid(self, response):
        response = super().form_valid(response)
        self.send_confirmation_email()
        return response

    def send_confirmation_email(self):
        context = {
            'user': self.request.user,
            'case': self.object,
        }
        
        subject = 'Case Submission Confirmation'
        message = render_to_string('emails/case_confirmation.html', context)
        
        send_mail(
            subject,
            message,
            settings.EMAIL_HOST_USER,
            [self.request.user.email],
            html_message=message,
        )

class CaseCreateView(LoginRequiredMixin, CreateView):
    model = Case
    form_class = CaseForm
    template_name = 'cases/create_case.html'

    def get_success_url(self):
        return reverse('cases:dashboard')

    def form_valid(self, form):
        form.instance.user = self.request.user
        return super().form_valid(form)

class DashboardView(LoginRequiredMixin, ListView):
    model = Case
    template_name = 'cases/dashboard.html'
    context_object_name = 'cases'

    def get_queryset(self):
        return Case.objects.filter(user=self.request.user)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        completed_cases = self.get_queryset().filter(status='completed')
        context['completed_amount'] = completed_cases.aggregate(Sum('amount_lost'))['amount_lost__sum'] or 0
        return context
        
class VerificationView(LoginRequiredMixin, DetailView):
    model = Case
    template_name = 'cases/verification.html'
    context_object_name = 'case'

    def get_queryset(self):
        return Case.objects.filter(user=self.request.user)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        case = self.get_object()
        
        # Get all verification steps and their status
        verification_steps = []
        completed_steps = case.verificationcode_set.filter(is_used=True).values_list('step', flat=True)
        
        for step_num, step_name in VerificationCode.STEP_CHOICES:
            verification_steps.append({
                'number': step_num,
                'name': step_name,
                'completed': step_num in completed_steps,
                'current': step_num == len(completed_steps) + 1
            })
        
        context['verification_steps'] = verification_steps
        context['current_step'] = len(completed_steps) + 1
        return context

    def post(self, request, *args, **kwargs):
        case = self.get_object()
        code = request.POST.get('code')
        current_step = case.verificationcode_set.filter(is_used=True).count() + 1

        try:
            verification = VerificationCode.objects.get(
                case=case,
                step=current_step,
                code=code,
                is_used=False
            )
            
            # Check if code is expired
            if verification.is_expired():
                return JsonResponse({
                    'success': False,
                    'error': 'Verification code has expired'
                })

            # Mark code as used
            verification.is_used = True
            verification.save()

            # Check if this was the final step
            if current_step == 3:
                case.status = 'completed'
                case.save()

            return JsonResponse({
                'success': True,
                'message': f'Step {current_step} verified successfully'
            })
            
        except VerificationCode.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Invalid verification code'
            })

# cases/models.py
from django.db import models
from django.conf import settings
import random
import string
from django.utils import timezone
from datetime import timedelta

class Case(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('reviewing', 'Under Review'),
        ('approved', 'Approved'),
        ('completed', 'Completed'),
        ('rejected', 'Rejected')
    ]
    
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    company = models.CharField(max_length=255)
    amount_lost = models.DecimalField(max_digits=10, decimal_places=2)
    payment_method = models.CharField(max_length=100)
    wallet_address = models.CharField(max_length=255)
    description = models.TextField()
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"Case #{self.id} - {self.user.username}"

    def get_verification_progress(self):
        """Returns the number of completed verification steps"""
        return self.verificationcode_set.filter(is_used=True).count()

    def is_verification_complete(self):
        """Checks if all verification steps are completed"""
        return self.get_verification_progress() == 3

    def get_current_step(self):
        """Returns the current verification step (1-3) or None if complete"""
        completed_steps = self.get_verification_progress()
        return None if completed_steps >= 3 else completed_steps + 1

class VerificationCode(models.Model):
    STEP_CHOICES = [
        (1, 'Identity Verification'),
        (2, 'Document Verification'),
        (3, 'Final Verification')
    ]
    
    case = models.ForeignKey('Case', on_delete=models.CASCADE)
    step = models.IntegerField(choices=STEP_CHOICES)
    code = models.CharField(max_length=20)
    is_used = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField(null=True)

    class Meta:
        unique_together = ['case', 'step']
        ordering = ['step']

    def save(self, *args, **kwargs):
        # Generate code if not provided
        if not self.code:
            self.code = self.generate_code()
        
        # Set expiration if not provided
        if not self.expires_at:
            self.expires_at = timezone.now() + timedelta(minutes=30)
            
        super().save(*args, **kwargs)

    def is_expired(self):
        """Check if the verification code has expired"""
        return self.expires_at and timezone.now() > self.expires_at

    def is_valid(self):
        """Check if the code is still valid (not used and not expired)"""
        return not self.is_used and not self.is_expired()

    @staticmethod
    def generate_code():
        """Generate a random 6-character alphanumeric code"""
        return ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))

    def __str__(self):
        return f"Case #{self.case.id} - {self.get_step_display()} Code"

    @classmethod
    def create_for_case(cls, case, step):
        """Create a new verification code for a specific case and step"""
        existing_code = cls.objects.filter(case=case, step=step, is_used=False).first()
        if existing_code:
            if existing_code.is_expired():
                existing_code.delete()
            else:
                return existing_code

        return cls.objects.create(
            case=case,
            step=step,
            code=cls.generate_code(),
            expires_at=timezone.now() + timedelta(minutes=30)
        )

    def mark_as_used(self):
        """Mark the verification code as used and update case status if needed"""
        if not self.is_used and not self.is_expired():
            self.is_used = True
            self.save()
            
            # If this was the final step, mark the case as completed
            if self.step == 3:
                self.case.status = 'completed'
                self.case.save()
            
            return True
        return False
    
class Withdrawal(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=20, choices=[
        ('pending', 'Pending'),
        ('completed', 'Completed'),
        ('rejected', 'Rejected')
    ], default='pending')

    def __str__(self):
        return f"Withdrawal #{self.id} - {self.user.username} - ${self.amount}"








# cases/urls.py
from django.urls import path
from . import views, api

app_name = 'cases'

urlpatterns = [
    path('', views.DashboardView.as_view(), name='dashboard'),
    path('case/new/', views.CaseCreateView.as_view(), name='create_case'),
    path('case/<int:pk>/verify/', views.VerificationView.as_view(), name='verify'),
    path('api/case/<int:case_id>/verify/', api.verify_code, name='api_verify'),
    path('api/case/<int:case_id>/request-code/', api.request_new_code, name='api_request_code'),
]

# cases/utils.py
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.conf import settings

def send_verification_code_email(case, code, step):
    context = {
        'user': case.user,
        'case': case,
        'code': code,
        'step': step,
    }
    
    subject = f'Verification Code for Step {step}'
    message = render_to_string('emails/verification_code.html', context)
    
    send_mail(
        subject,
        message,
        settings.EMAIL_HOST_USER,
        [case.user.email],
        html_message=message,
    )



    # cases/middleware.py
from django.shortcuts import redirect
from django.urls import reverse
from .models import Case

class VerificationMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        if request.user.is_authenticated and request.path.startswith('/case/'):
            try:
                case_id = int(request.path.split('/')[2])
                case = Case.objects.get(id=case_id, user=request.user)
                if case.status == 'approved':
                    verification_codes = case.verificationcode_set.filter(is_used=True)
                    request.current_step = len(verification_codes) + 1
            except (IndexError, ValueError, Case.DoesNotExist):
                pass

        response = self.get_response(request)
        return response



# cases/forms.py
from django import forms
from .models import Case

class CaseForm(forms.ModelForm):
    class Meta:
        model = Case
        fields = ['company', 'amount_lost', 'payment_method', 'wallet_address', 'description']
        widgets = {
            'description': forms.Textarea(attrs={'rows': 4}),
        }





























# cases/urls.py
from django.urls import path
from . import views, api

app_name = 'cases'

urlpatterns = [
    path('', views.DashboardView.as_view(), name='dashboard'),
    path('case/new/', views.CaseCreateView.as_view(), name='create_case'),
    path('case/<int:pk>/verify/', views.VerificationView.as_view(), name='verify'),
    path('api/case/<int:case_id>/verify/', api.verify_code, name='api_verify'),
    path('api/case/<int:case_id>/request-code/', api.request_new_code, name='api_request_code'),
    path('withdrawal/new/', views.WithdrawalCreateView.as_view(), name='create_withdrawal'),
]



 # cases/views.py
from django.db.models import Sum
from django.contrib import messages
from django.shortcuts import redirect
from django.utils import timezone
from django.http import JsonResponse
from django.views.generic import CreateView, ListView, DetailView
from django.contrib.auth.mixins import LoginRequiredMixin
from .models import Case, VerificationCode
from .forms import CaseForm, KYCVerificationForm
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.conf import settings
from django.urls import reverse
from .models import Withdrawal, KYCVerification
from .forms import WithdrawalForm
from django.urls import reverse_lazy

class CaseCreateView(LoginRequiredMixin, CreateView):
    # ... existing code ...

    def form_valid(self, response):
        response = super().form_valid(response)
        self.send_confirmation_email()
        return response

    def send_confirmation_email(self):
        context = {
            'user': self.request.user,
            'case': self.object,
        }
        
        subject = 'Case Submission Confirmation'
        message = render_to_string('emails/case_confirmation.html', context)
        
        send_mail(
            subject,
            message,
            settings.EMAIL_HOST_USER,
            [self.request.user.email],
            html_message=message,
        )

class CaseCreateView(LoginRequiredMixin, CreateView):
    model = Case
    form_class = CaseForm
    template_name = 'cases/create_case.html'

    def get_success_url(self):
        return reverse('cases:dashboard')

    def form_valid(self, form):
        form.instance.user = self.request.user
        return super().form_valid(form)

class DashboardView(LoginRequiredMixin, ListView):
    model = Case
    template_name = 'cases/dashboard.html'
    context_object_name = 'cases'

    def get_queryset(self):
        return Case.objects.filter(user=self.request.user)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        completed_cases = self.get_queryset().filter(status='completed')
        context['completed_amount'] = completed_cases.aggregate(Sum('amount_lost'))['amount_lost__sum'] or 0
        context['total_withdrawn'] = Withdrawal.objects.filter(user=self.request.user, status='completed').aggregate(Sum('amount'))['amount__sum'] or 0
        context['recent_withdrawals'] = Withdrawal.objects.filter(user=self.request.user).order_by('created_at')[:5]
        return context
        
class VerificationView(LoginRequiredMixin, DetailView):
    model = Case
    template_name = 'cases/verification.html'
    context_object_name = 'case'

    def get_queryset(self):
        return Case.objects.filter(user=self.request.user)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        case = self.get_object()
        
        # Get all verification steps and their status
        verification_steps = []
        completed_steps = case.verificationcode_set.filter(is_used=True).values_list('step', flat=True)
        
        for step_num, step_name in VerificationCode.STEP_CHOICES:
            verification_steps.append({
                'number': step_num,
                'name': step_name,
                'completed': step_num in completed_steps,
                'current': step_num == len(completed_steps) + 1
            })
        
        context['verification_steps'] = verification_steps
        context['current_step'] = len(completed_steps) + 1
        return context

    def post(self, request, *args, **kwargs):
        case = self.get_object()
        code = request.POST.get('code')
        current_step = case.verificationcode_set.filter(is_used=True).count() + 1

        try:
            verification = VerificationCode.objects.get(
                case=case,
                step=current_step,
                code=code,
                is_used=False
            )
            
            # Check if code is expired
            if verification.is_expired():
                return JsonResponse({
                    'success': False,
                    'error': 'Verification code has expired'
                })

            # Mark code as used
            verification.is_used = True
            verification.save()

            # Check if this was the final step
            if current_step == 3:
                case.status = 'completed'
                case.save()

            return JsonResponse({
                'success': True,
                'message': f'Step {current_step} verified successfully'
            })
            
        except VerificationCode.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Invalid verification code'
            })
        
class WithdrawalCreateView(LoginRequiredMixin, CreateView):
    model = Withdrawal
    form_class = WithdrawalForm
    template_name = 'cases/create_withdrawal.html'
    success_url = reverse_lazy('cases:dashboard')

    def dispatch(self, request, *args, **kwargs):
        try:
            kyc = KYCVerification.objects.get(user=request.user)
            if not kyc.is_verified:
                messages.warning(request, "You need to complete KYC verification before making a withdrawal.")
                return redirect(reverse('cases:kyc_verification'))
        except KYCVerification.DoesNotExist:
            messages.warning(request, "You need to complete KYC verification before making a withdrawal.")
            return redirect(reverse('cases:kyc_verification'))
        return super().dispatch(request, *args, **kwargs)

    def form_valid(self, form):
        form.instance.user = self.request.user
        try:
            response = super().form_valid(form)
            messages.success(self.request, f"Withdrawal request for ${form.instance.amount} has been submitted.")
            return response
        except ValueError as e:
            messages.error(self.request, str(e))
            return self.form_invalid(form)
        
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        total_balance = Case.objects.filter(user=self.request.user, status='completed').aggregate(Sum('amount_lost'))['amount_lost__sum'] or 0
        total_withdrawn = Withdrawal.objects.filter(user=self.request.user, status='completed').aggregate(Sum('amount'))['amount__sum'] or 0
        available_balance = total_balance - total_withdrawn
        
        context.update({
            'total_balance': total_balance,
            'total_withdrawn': total_withdrawn,
            'available_balance': available_balance,
        })
        return context

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['user'] = self.request.user
        return kwargs

# Add a new view for KYC verification
class KYCVerificationView(LoginRequiredMixin, CreateView):
    model = KYCVerification
    form_class = KYCVerificationForm
    template_name = 'cases/kyc_verification.html'
    success_url = reverse_lazy('cases:dashboard')

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        if self.request.method == 'POST':
            kwargs['instance'] = KYCVerification.objects.get_or_create(user=self.request.user)[0]
        return kwargs

    def form_valid(self, form):
        form.instance.user = self.request.user
        response = super().form_valid(form)
        messages.success(self.request, "Your KYC verification has been submitted for review.")
        return response
    

from django.views.generic import TemplateView

# Add this new view at the top of the file
class HomeView(TemplateView):
    template_name = 'cases/home.html'

